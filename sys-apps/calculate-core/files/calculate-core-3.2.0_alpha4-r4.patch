diff --git core/server/api_types.py core/server/api_types.py
index 3863d53..eb205c1 100644
--- core/server/api_types.py
+++ core/server/api_types.py
@@ -164,6 +164,97 @@ class Table(DataVarsSerializer):
             self.onClick = onClick
             self.addAction = addAction
 
+class ChoiceValueAdapter(object):
+    def __init__(self, choicevalue):
+        self.choicevalue = choicevalue
+
+    @property
+    def values(self):
+        return self.choicevalue.values.string
+
+    @property
+    def comments(self):
+        return self.choicevalue.comments.string
+
+    @property
+    def onChanged(self):
+        return self.choicevalue.onChanged.string
+
+    def __getattr__(self, item):
+        return getattr(self.choicevalue, item)
+
+    @classmethod
+    def from_detect(cls, choicevalue):
+        if isinstance(choicevalue, ChoiceValue):
+            return choicevalue
+        else:
+            return cls(choicevalue)
+
+class TableAdapter(object):
+    def __init__(self, table):
+        self.table = table
+
+    @property
+    def fields(self):
+        return self.table.fields.string
+
+    @property
+    def head(self):
+        return self.table.head.string
+
+    @property
+    def body(self):
+        if hasattr(self.table.body,'stringArray'):
+            return [row.string
+                    for row in self.table.body.stringArray
+                    if hasattr(row, "string")]
+        return []
+
+    @property
+    def values(self):
+        return [ChoiceValueAdapter(x) for  x in self.table.values.ChoiceValue]
+
+    def __getattr__(self, item):
+        return getattr(self.table, item)
+
+    @classmethod
+    def from_detect(cls, table):
+        if isinstance(table, Table):
+            return table
+        else:
+            return cls(table)
+
+class FieldAdapter(object):
+    def __init__(self, field):
+        self.field = field
+
+    @property
+    def choice(self):
+        return self.field.choice.string
+
+    @property
+    def listvalue(self):
+        return self.field.listvalue.string
+
+    @property
+    def comments(self):
+        return self.field.comments.string
+
+    @property
+    def tablevalue(self):
+        return TableAdapter(self.field.tablevalue)
+
+    def __getattr__(self, item):
+        return getattr(self.field, item)
+
+    @classmethod
+    def from_detect(cls, field):
+        if isinstance(field, Field):
+            return field
+        else:
+            return cls(field)
+
+
 class Option(DataVarsSerializer):
     shortopt = String
     longopt = String
diff --git core/server/replace_class.py core/server/replace_class.py
index 23c5282..6901ef6 100644
--- core/server/replace_class.py
+++ core/server/replace_class.py
@@ -34,6 +34,7 @@ from calculate.lib.utils.colortext.output import BaseOutput
 from calculate.lib.cl_print import color_print
 from calculate.lib.datavars import VariableError
 from calculate.lib.cl_lang import setLocalTranslate
+from calculate.core.server.api_types import FieldAdapter
 
 from methods_func import get_method_argparser, collect_object, \
     check_result_msg, get_param_pwd, _print
@@ -44,7 +45,7 @@ from func import shortTraceback, CommonMethods
 
 
 setLocalTranslate('cl_core3', sys.modules[__name__])
-from itertools import cycle
+from itertools import cycle, izip, ifilter
 import time
 
 
@@ -411,9 +412,9 @@ class replaceClass():
                         yes_color, no_color = Colors.GREEN, Colors.LIGHT_RED
                     else:
                         yes_color, no_color = Colors.LIGHT_RED, Colors.GREEN
-                    yes = _print.foreground(yes_color).bold("Yes")
-                    no = _print.foreground(no_color).bold("No")
-                    white_message = _print.foreground(Colors.WHITE).bold(
+                    yes = _print.foreground(yes_color)("Yes")
+                    no = _print.foreground(no_color)("No")
+                    white_message = _print.foreground(Colors.WHITE)(
                         message)
                     ask = raw_input(white_message + ' (%s/%s): ' % (yes, no))
                 except KeyboardInterrupt:
@@ -445,7 +446,7 @@ class replaceClass():
                 useGetChar = False
             else:
                 useGetChar = True
-            message = _print.foreground(Colors.WHITE).bold(message)
+            message = _print.foreground(Colors.WHITE)(message)
 
             while True:
                 outMessage = message + ' (%s): ' % \
@@ -531,7 +532,7 @@ class replaceClass():
         def startGroup(self, message):
             _print = get_terminal_print()
             self.printDefault(
-                _print.foreground(TextState.Colors.WHITE).bold(message))
+                _print.foreground(TextState.Colors.WHITE)(message))
             #self.addMessage(type='startGroup', message=message)
 
         def endGroup(self):
@@ -766,159 +767,179 @@ def print_brief(view, brief_label):
         print_brief_group(Group.fields, Group.name)
 
 
-def print_brief_group(Fields, group_name):
-    print_group_flag = False
-    #    if group_name:
-    #        _print ('\b'+group_name)
-    uncompatible_count = 0
-    colorPrint = color_print()
-    _colorprint = get_terminal_print(_print)
-    for field in Fields:
-        if field.uncompatible:
-            uncompatible_count += 1
-            continue
-        if field.element in ['input', 'openfile']:
-            value = field.value if field.value else ''
-            if not print_group_flag:
-                if group_name:
-                    print_group_flag = True
-                    _colorprint.bold.foreground(
-                        TextState.Colors.WHITE)(group_name)
-            colorPrint.printSUCCESS('%s: %s' % (field.label, value))
-
-        elif field.element in ['combo', 'comboEdit', 'radio', 'file']:
-            if field.choice:
-                if not field.choice[0]:
-                    field.choice.pop(0)
-            if field.comments:
-                if not field.comments[0]:
-                    field.comments.pop(0)
-            if field.comments and field.choice:
-                if not field.value in field.choice:
-                    field.choice.append(field.value)
-                value = map(lambda x: field.comments[x] \
-                    if len(field.comments) > x else field.choice[x],
-                            map(lambda x: field.choice.index(x),
-                                filter(lambda x: x in field.choice,
-                                       [field.value])))
-                value = ', '.join(value)
-            else:
-                value = field.value if field.value else ''
-            if not print_group_flag:
-                if group_name:
-                    print_group_flag = True
-                    #_print('\b' + group_name)
-                    _colorprint.bold.foreground(
-                        TextState.Colors.WHITE)(group_name)
-            colorPrint.printSUCCESS('%s: %s' % (field.label, value))
-
-        elif field.element in ['multichoice', 'multichoice_add', \
-                               'selecttable', 'selecttable_add']:
-            if field.choice:
-                if not field.choice[0]:
-                    field.choice.pop(0)
-            if field.comments:
-                if not field.comments[0]:
-                    field.comments.pop(0)
-            if field.listvalue:
-                if not field.listvalue[0]:
-                    field.listvalue.pop(0)
-            if field.choice:
-                value = map(lambda x: field.comments[x] \
-                    if len(field.comments) > x \
-                    else field.choice[x],
-                            map(lambda x: field.choice.index(x), \
-                                field.listvalue))
+class Display(object):
+    def __init__(self):
+        self._print = get_terminal_print(color_print().defaultPrint)
+
+    def print_info(self, label, value):
+        GREEN = TextState.Colors.GREEN
+        self.display_asterisk(GREEN)
+        self._print("%s: " % label)
+        WHITE = TextState.Colors.WHITE
+        self._print.foreground(WHITE)(value)
+        self._print("\n")
+
+    def print_label(self, label):
+        GREEN = TextState.Colors.GREEN
+        self.display_asterisk(GREEN)
+        self._print("%s: " % label)
+        self._print("\n")
+
+    def display_asterisk(self, color):
+        self._print(" ")
+        self._print.foreground(color).bold("*")
+        self._print(" ")
+
+    def print_error(self, message):
+        RED = TextState.Colors.RED
+        self.display_asterisk(RED)
+        self._print(message)
+        self._print("\n")
+
+    def print_table(self, data, head):
+
+        sys.stdout.write('%s\n' % printTable(data, head))
+
+    def print_group(self, label):
+        #WHITE = TextState.Colors.WHITE
+        #self._print.foreground(WHITE).bold(label)
+        #self._print.underline(label)
+        self._print(label)
+        self._print("\n")
+
+
+class InformationElement(object):
+    def __init__(self, field, display):
+        self.value = ""
+        self.label = ""
+        self.display = display
+
+    @classmethod
+    def from_field(cls, field, display):
+        if field.type == 'steps':
+            return None
+        map_elements = {'input': ValueInfo,
+                       'openfile': ValueInfo,
+                       'combo': ChoiceInfo,
+                       'comboEdit': ChoiceInfo,
+                       'radio': ChoiceInfo,
+                       'file': ChoiceInfo,
+                       'multichoice': MultiChoiceInfo,
+                       'multichoice_add': MultiChoiceInfo,
+                       'selecttable': MultiChoiceInfo,
+                       'selecttable_add': MultiChoiceInfo,
+                       'error': ErrorInfo,
+                       'check': CheckInfo,
+                       'check_tristate': CheckInfo,
+                       'table': TableInfo
+                       }
+        if field.element in map_elements:
+            return map_elements[field.element](field, display)
+        return None
+
+    def show(self):
+        self.display.print_info(self.label, self.value)
+
+
+class ValueInfo(InformationElement):
+    def __init__(self, field, display):
+        super(ValueInfo, self).__init__(field, display)
+        self.value = field.value or ''
+        self.label = field.label
+
+class CheckInfo(InformationElement):
+    def __init__(self, field, display):
+        super(CheckInfo, self).__init__(field, display)
+        self.label = field.label
+        map_answer = {'on':_('yes'), 'off': _("no"), 'auto': _('auto')}
+        self.value = map_answer.get(field.value, field.value)
+
+class ChoiceInfo(InformationElement):
+    def __init__(self, field, display):
+        super(ChoiceInfo, self).__init__(field, display)
+        self.label = field.label or ''
+        if field.choice and field.comments:
+            map_comment = dict(zip(field.choice, field.comments))
+            self.value = map_comment.get(field.value, field.value) or ''
+        else:
+            self.value = field.value if field.value else ''
+
+
+class MultiChoiceInfo(InformationElement):
+    def __init__(self, field, display):
+        super(MultiChoiceInfo, self).__init__(field, display)
+        self.label = field.label or ''
+        if field.listvalue:
+            value = field.listvalue
+            # удалить пустой первый элемент (особенности wsdl)
+            if value and not value[0]:
+                value.pop(0)
+            if field.choice and field.comments:
+                map_comment = dict(zip(field.choice, field.comments))
             else:
-                value = []
-            value = ', '.join(value)
-            if field.listvalue and not value:
-                value = ', '.join(field.listvalue)
-            elif not value:
-                value = field.value if field.value else ''
-            if not print_group_flag:
-                if group_name:
-                    print_group_flag = True
-                    #_print('\b' + group_name)
-                    _colorprint.bold.foreground(
-                        TextState.Colors.WHITE)(group_name)
-            colorPrint.printSUCCESS('%s: %s' % (field.label, value))
-
-        #        elif field.element == 'label':
-        #            print field.label
-
-        elif field.element == 'error':
-            if not print_group_flag:
-                if group_name:
-                    print_group_flag = True
-                    _colorprint.bold.foreground(
-                        TextState.Colors.WHITE)(group_name)
-            colorPrint.printERROR(field.label)
-
-        elif field.element in ['check', 'check_tristate']:
-            if field.value == 'on':
-                value = _('yes')
-            elif field.value == 'off':
-                value = _('no')
-            elif field.value == 'auto':
-                value = _('auto')
+                map_comment = {}
+            self.value = ", ".join([map_comment.get(x, x) or '' for x in value])
+        else:
+            self.value = field.value or ""
+
+
+class ErrorInfo(InformationElement):
+    def __init__(self, field, display):
+        super(ErrorInfo, self).__init__(field, display)
+        self.label = field.label
+
+    def show(self):
+        self.display.print_error(self.label)
+
+
+class TableInfo(InformationElement):
+    """
+    Табличная информация
+    """
+
+    def map_row(self, row, typedata):
+        map_answer = {'on':_('yes'), 'off': _("no"), 'auto': _('auto')}
+        for cell, typefield in izip(row, typedata):
+            if typefield in ['check', 'check_tristate']:
+                yield map_answer.get(cell, cell) or ""
+            elif "password" in typefield:
+                yield "***"
             else:
-                value = field.value
-            if not print_group_flag:
-                if group_name:
-                    print_group_flag = True
-                    _colorprint.bold.foreground(
-                        TextState.Colors.WHITE)(group_name)
-            colorPrint.printSUCCESS('%s: %s' % (field.label, value))
-
-        elif field.element == 'table' and field.type != 'steps':
-            head = field.tablevalue.head
-
-            body = []
-            for row in field.tablevalue.body:
-                if not row[0]:
-                    row.pop(0)
-                body.append(row)
-
-            # if empty table
-            if not filter(None, map(lambda x: x, body)):
-                body = [[''] * len(head)]
-                res = printTable(body, head)
-                sys.stdout.flush()
-                sys.stdout.write(res + "\n")
-                continue
-            ChoiceValue = field.tablevalue.values
-            for row in xrange(len(ChoiceValue)):
-                if ChoiceValue[row].typefield in ['check', 'check_tristate']:
-                    for i in xrange(len(body)):
-                        if body[i][row] == 'on':
-                            body[i][row] = _('yes')
-                        if body[i][row] == 'off':
-                            body[i][row] = _('no')
-                        if body[i][row] == 'auto':
-                            body[i][row] = _('auto')
-                if "password" in ChoiceValue[row].typefield:
-                    for i in xrange(len(body)):
-                        if body[i][row]:
-                            body[i][row] = '***'
-            data = []
-            for body_row in body:
-                data.append(map(lambda x: x if x else '', body_row))
-            if not print_group_flag:
-                if group_name:
-                    print_group_flag = True
-                    _colorprint.bold.foreground(
-                        TextState.Colors.WHITE)(group_name)
-            colorPrint.printSUCCESS(field.label + ': ')
-            res = printTable(data, head)
-            sys.stdout.flush()
-            sys.stdout.write(res + "\n")
+                yield cell or ""
+
+    def __init__(self, field, display):
+        super(TableInfo, self).__init__(field, display)
+        self.label = field.label
+        self.head = field.tablevalue.head
+
+        # удаление первого элемента строки (для wsdl)
+        body = [x[1:] if x and not x[0] else x for x in field.tablevalue.body]
+
+        if not filter(None, map(lambda x: x, body)):
+            self.body = None
         else:
-            uncompatible_count += 1
+            type_values = [x.typefield for x in field.tablevalue.values]
+            self.body = [list(self.map_row(x, type_values)) for x in body]
+
+    def show(self):
+        if self.body:
+            self.display.print_label(self.label)
+            self.display.print_table(self.body, self.head)
 
 
-#    if uncompatible_count == len (Fields) and group_name:
-#        colorPrint.printSUCCESS(_('Not used'))
+def print_brief_group(Fields, group_name):
+    display = Display()
+    show_group = True
+    for element in ifilter(None,
+                           (InformationElement.from_field(
+                                   FieldAdapter.from_detect(x),
+                                   display)
+                            for x in Fields if not x.uncompatible)):
+        if show_group:
+            display.print_group(group_name)
+            show_group = False
+        element.show()
+
 
 class Table(tableReport):
     def __init__(self, *args, **kwargs):
@@ -953,4 +974,3 @@ def printTable(data, header=None):
     except Exception as e:
         print str(e)
         raise
-
diff --git core/variables/certificate.py core/variables/certificate.py
index 7cbf9fe..8b1c0cf 100644
--- core/variables/certificate.py
+++ core/variables/certificate.py
@@ -204,7 +204,7 @@ class VariableClCertGroups(Variable):
                                            (OpenSSL.SSL.FILETYPE_PEM, cert)
             com = certobj.get_extension(certobj.get_extension_count()-1). \
                                         get_data()
-            groups = com.split(':')[1]
+            groups = com.rpartition(':')[2]
             groups_list = groups.split(',')
             return groups_list
         except (OpenSSL.crypto.Error,IOError) as e:
